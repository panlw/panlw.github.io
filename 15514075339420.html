<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  推荐一款很好用的内网穿透工具 FRP - Junkman
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="Junkman" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:panlw.github.io ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="http://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; Junkman</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
       
       <li><a href="index.html">HOME</a></li>
    <li><a href="archives.html">Archives</a></li>
    <li><a href="about.html">ABOUT</a></li>

    <li><label>Categories</label></li>

        
            <li><a href="Infra.html">Infra</a></li>
        
            <li><a href="Coding.html">Coding</a></li>
        
            <li><a href="Modeling.html">Modeling</a></li>
        
            <li><a href="Archtecting.html">Archtecting</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
  $(function(){
    $('#menu_item_index').addClass('is_active');
  });
</script>
<div class="row">
  <div class="large-8 medium-8 columns">
      <div class="markdown-body article-wrap">
       <div class="article">
          
          <h1>推荐一款很好用的内网穿透工具 FRP</h1>
     
        <div class="read-more clearfix">
          <span class="date">2019/3/1</span>

          <span>posted in&nbsp;</span> 
          
              <span class="posted-in"><a href='Network.html'>Network</a></span>
           
         
          <span class="comments">
            

            
          </span>

        </div>
      </div><!-- article -->

      <div class="article-content">
      <blockquote>
<p>原文地址 <a href="https://www.hi-linux.com/posts/25686.html">https://www.hi-linux.com/posts/25686.html</a></p>
</blockquote>

<p>对于没有公网 <code>IP</code> 的内网用户来说，远程管理或在外网访问内网机器上的服务是一个问题。通常解决方案就是用内网穿透工具将内网的服务穿透到公网中，便于远程管理和在外部访问。内网穿透的工具很多，之前也介绍过 <a href="https://www.hi-linux.com/posts/29097.html">Ngrok</a><a href="https://www.hi-linux.com/posts/24471.html">、Localtunnel</a>。</p>

<p>今天给大家介绍另一款好用内网穿透工具 <code>FRP</code>，<code>FRP</code> 全名：Fast Reverse Proxy。<code>FRP</code> 是一个使用 <code>Go</code> 语言开发的高性能的反向代理应用，可以帮助您轻松地进行内网穿透，对外网提供服务。<code>FRP</code> 支持 <code>TCP</code>、<code>UDP</code>、<code>HTTP</code>、<code>HTTPS</code>等协议类型，并且支持 <code>Web</code> 服务根据域名进行路由转发。</p>

<p>FRP 项目地址：<a href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a></p>

<p><strong>FRP 的作用</strong></p>

<ul>
<li>  利用处于内网或防火墙后的机器，对外网环境提供 <code>HTTP</code> 或 <code>HTTPS</code> 服务。</li>
<li>  对于 <code>HTTP</code>, <code>HTTPS</code> 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个 80 端口。</li>
<li>  利用处于内网或防火墙后的机器，对外网环境提供 <code>TCP</code> 和 <code>UDP</code> 服务，例如在家里通过 <code>SSH</code> 访问处于公司内网环境内的主机。</li>
</ul>

<p><strong>FRP 架构</strong></p>

<p><img src="https://www.hi-linux.com/img/linux/frp-architecture.png" alt=""/></p>

<h3 id="toc_0"><a href="#frp-%E5%AE%89%E8%A3%85"></a>FRP 安装</h3>

<p><code>FRP</code> 采用 <code>Go</code> 语言开发，支持 <code>Windows</code>、<code>Linux</code>、<code>MacOS</code>、<code>ARM</code>等多平台部署。<code>FRP</code> 安装非常容易，只需下载对应系统平台的软件包，并解压就可用了。</p>

<p>这里以 <code>Linux</code> 为例，为了方便管理我们把解压后的目录重命名为 frp ：</p>

<pre><code class="language-sh">$ wget https://github.com/fatedier/frp/releases/download/v0.15.1/frp_0.15.1_linux_amd64.tar.gz
$ tar xzvf frp_0.15.1_linux_amd64.tar.gz
$ mv frp_0.15.1_linux_amd64 frp
</code></pre>

<p>更多平台的软件包下载地址：<a href="https://github.com/fatedier/frp/releases">https://github.com/fatedier/frp/releases</a></p>

<h3 id="toc_1"><a href="#frp-%E9%85%8D%E7%BD%AE"></a>FRP 配置</h3>

<h4 id="toc_2"><a href="#frp-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%85%8D%E7%BD%AE"></a>FRP 服务端配置</h4>

<p>配置 <code>FRP</code> 服务端的前提条件是需要一台具有公网 <code>IP</code> 的设备，得益于 <code>FRP</code> 是 <code>Go</code> 语言开发的，具有良好的跨平台特性。你可以在 <code>Windows</code>、<code>Linux</code>、<code>MacOS</code>、<code>ARM</code>等几乎任何可联网设备上部署。</p>

<p>这里以 <code>Linux</code> 为例，<code>FRP</code> 默认给出两个服务端配置文件，一个是简版的 frps.ini，另一个是完整版本 frps_full.ini。</p>

<p>我们先来看看简版的 frps.ini，通过这个配置可以快速的搭建起一个 FRP 服务端。</p>

<pre><code class="language-sh">$ cat frps.ini

[common]
bind_port = 7000
</code></pre>

<blockquote>
<ul>
<li>  默认配置中监听的是 7000 端口，可根据自己实际情况修改。</li>
</ul>
</blockquote>

<p>启动 FRP 服务端</p>

<pre><code class="language-sh">$ ./frps -c ./frps.ini
2018/01/25 10:52:45 [I] [service.go:96] frps tcp listen on 0.0.0.0:7000
2018/01/25 10:52:45 [I] [main.go:112] Start frps success
2018/01/25 10:52:45 [I] [main.go:114] PrivilegeMode is enabled, you should pay more attention to security issues
</code></pre>

<p>通过上面简单的两步就可以成功启动一个监听在 7000 端口的 <code>FRP</code> 服务端。</p>

<h4 id="toc_3"><a href="#frp-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE"></a>FRP 客户端配置</h4>

<p>和 FRP 服务端类似，<code>FRP</code> 默认也给出两个客户端配置文件，一个是简版的 frpc.ini，另一个是完整版本 frpc_full.ini。</p>

<p>这里同样以简版的 frpc.ini 文件为例，假设 FRP 服务端所在服务器的公网 <code>IP</code> 为 4.3.2.1。</p>

<pre><code class="language-sh">$ vim frpc.ini

[common]
# server_addr 为 FRP 服务端的公网 IP 
server_addr = 4.3.2.1
# server_port 为 FRP 服务端监听的端口 
server_port = 7000
</code></pre>

<p>启动 FRP 客户端</p>

<pre><code>$ ./frpc -c ./frpc.ini
2018/01/25 11:15:49 [I] [proxy_manager.go:284] proxy removed: []
2018/01/25 11:15:49 [I] [proxy_manager.go:294] proxy added: []
2018/01/25 11:15:49 [I] [proxy_manager.go:317] visitor removed: []
2018/01/25 11:15:49 [I] [proxy_manager.go:326] visitor added: []
2018/01/25 11:15:49 [I] [control.go:240] [83775d7388b8e7d9] login to server success, get run id [83775d7388b8e7d9], server udp port [0]
</code></pre>

<p>这样就可以成功在 <code>FRP</code> 服务端上成功建立一个客户端连接，当然现在还并不能对外提供任何内网机器上的服务，因为我们并还没有在 <code>FRP</code> 服务端注册任何内网服务的端口。</p>

<h3 id="toc_4"><a href="#frp-%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B"></a>FRP 使用实例</h3>

<p>下面我们就来看几个常用的例子，通过这些例子来了解下 FRP 是如何实现内网服务穿透的。</p>

<h4 id="toc_5"><a href="#%E9%80%9A%E8%BF%87-tcp-%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91%E6%9C%BA%E5%99%A8"></a>通过 TCP 访问内网机器</h4>

<p>这里以访问 <code>SSH</code> 服务为例， 修改 FRP 客户端配置文件 frpc.ini 文件并增加如下内容：</p>

<pre><code class="language-sh">$ cat frpc.ini

[ssh]
type = tcp
local_ip = 127.0.0.1
local_port = 22
remote_port = 6000
</code></pre>

<p>启动 FRP 客户端</p>

<pre><code class="language-sh">$ ./frpc -c ./frpc.ini
2018/01/25 12:21:23 [I] [proxy_manager.go:284] proxy removed: []
2018/01/25 12:21:23 [I] [proxy_manager.go:294] proxy added: [ssh]
2018/01/25 12:21:23 [I] [proxy_manager.go:317] visitor removed: []
2018/01/25 12:21:23 [I] [proxy_manager.go:326] visitor added: []
2018/01/25 12:21:23 [I] [control.go:240] [3b468a55191341cb] login to server success, get run id [3b468a55191341cb], server udp port [0]
2018/01/25 12:21:23 [I] [control.go:165] [3b468a55191341cb] [ssh] start proxy success
</code></pre>

<p>这样就在 <code>FRP</code> 服务端上成功注册了一个端口为 6000 的服务，接下来我们就可以通过这个端口访问内网机器上 <code>SSH</code> 服务，假设用户名为 mike：</p>

<pre><code class="language-sh">$ ssh -oPort=6000 mike@4.3.2.1
</code></pre>

<h4 id="toc_6"><a href="#%E9%80%9A%E8%BF%87%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE%E9%83%A8%E7%BD%B2%E4%BA%8E%E5%86%85%E7%BD%91%E7%9A%84-web-%E6%9C%8D%E5%8A%A1"></a>通过自定义域名访问部署于内网的 Web 服务</h4>

<p>有时需要在公有网络通过域名访问我们在本地环境搭建的 <code>Web</code> 服务，但是由于本地环境机器并没有公网 <code>IP</code>，无法将域名直接解析到本地的机器。</p>

<p>现在通过 <code>FRP</code> 就可以很容易实现这一功能，这里以 <code>HTTP</code> 服务为例：首先修改 <code>FRP</code> 服务端配置文件，通过 <code>vhost_http_port</code> 参数来设置 <code>HTTP</code> 访问端口，这里将 <code>HTTP</code> 访问端口设为 8080。</p>

<pre><code class="language-sh">$ vim frps.ini
[common]
bind_port = 7000
vhost_http_port = 8080
</code></pre>

<p>启动 FRP 服务端</p>

<pre><code>$ ./frps -c ./frps.ini
2018/01/25 13:33:26 [I] [service.go:96] frps tcp listen on 0.0.0.0:7000
2018/01/25 13:33:26 [I] [service.go:125] http service listen on 0.0.0.0:8080
2018/01/25 13:33:26 [I] [main.go:112] Start frps success
2018/01/25 13:33:26 [I] [main.go:114] PrivilegeMode is enabled, you should pay more attention to security issues
</code></pre>

<p>其次我们在修改 <code>FRP</code> 客户端配置文件并增加如下内容：</p>

<pre><code class="language-sh">$ vim frpc.ini

[web]
type = http
local_port = 80
custom_domains = mike.hi-linux.com
</code></pre>

<p>这里通过 <code>local_port</code> 和 <code>custom_domains</code> 参数来设置本地机器上 <code>Web</code> 服务对应的端口和自定义的域名，这里我们分别设置端口为 80，对应域名为 <code>mike.hi-linux.com</code>。</p>

<p>启动 FRP 客户端</p>

<pre><code class="language-sh">$ ./frpc -c ./frpc.ini
2018/01/25 13:56:11 [I] [proxy_manager.go:284] proxy removed: []
2018/01/25 13:56:11 [I] [proxy_manager.go:294] proxy added: [web ssh]
2018/01/25 13:56:11 [I] [proxy_manager.go:317] visitor removed: []
2018/01/25 13:56:11 [I] [proxy_manager.go:326] visitor added: []
2018/01/25 13:56:11 [I] [control.go:240] [296fe9e31a551e07] login to server success, get run id [296fe9e31a551e07], server udp port [0]
2018/01/25 13:56:11 [I] [control.go:165] [296fe9e31a551e07] [web] start proxy success
2018/01/25 13:56:11 [I] [control.go:165] [296fe9e31a551e07] [ssh] start proxy success
</code></pre>

<p>最后将 <code>mike.hi-linux.com</code> 的域名 A 记录解析到 <code>FRP</code> 服务器的公网 <code>IP</code> 上，现在便可以通过 <code>http://mike.hi-linux.com:8080</code> 这个 <code>URL</code> 访问到处于内网机器上对应的 <code>Web</code> 服务。</p>

<blockquote>
<ul>
<li>  <code>HTTPS</code> 服务配置方法类似，只需将 <code>vhost_http_port</code> 替换为 <code>vhost_https_port</code>， type 设置为 <code>https</code> 即可。</li>
</ul>
</blockquote>

<h5 id="toc_7"><a href="#%E9%80%9A%E8%BF%87%E5%AF%86%E7%A0%81%E4%BF%9D%E6%8A%A4%E4%BD%A0%E7%9A%84-web-%E6%9C%8D%E5%8A%A1"></a>通过密码保护你的 Web 服务</h5>

<p>由于所有客户端共用一个 <code>FRP</code> 服务端的 <code>HTTP</code> 服务端口，任何知道你的域名和 <code>URL</code> 的人都能访问到你部署在内网的 <code>Web</code> 服务，但是在某些场景下需要确保只有限定的用户才能访问。</p>

<p><code>FRP</code> 支持通过 HTTP Basic Auth 来保护你的 <code>Web</code> 服务，使用户需要通过用户名和密码才能访问到你的服务。需要实现此功能主要需要在 <code>FRP</code> 客户端的配置文件中添加用户名和密码的设置。</p>

<pre><code class="language-sh">$ vim frpc.ini

[web]
type = http
local_port = 80
custom_domains = mike.hi-linux.com
# 设置认证的用户名
http_user = abc
# 设置认证的密码
http_pwd = abc
</code></pre>

<p>这时访问 <code>http://mike.hi-linux.com:8080</code> 这个 URL 时就需要输入配置的用户名和密码才能访问。</p>

<blockquote>
<ul>
<li>  该功能目前仅限于 HTTP 类型的代理。</li>
</ul>
</blockquote>

<h5 id="toc_8"><a href="#%E7%BB%99-web-%E6%9C%8D%E5%8A%A1%E5%A2%9E%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D"></a>给 Web 服务增加自定义二级域名</h5>

<p>在多人同时使用一个 <code>FRP</code> 服务端实现 <code>Web</code> 服务时，通过自定义二级域名的方式来使用会更加方便。</p>

<p>通过在 <code>FRP</code> 服务端的配置文件中配置 <code>subdomain_host</code>参数就可以启用该特性。之后在 <code>FRP</code> 客户端的 http、https 类型的代理中可以不配置 <code>custom_domains</code>，而是配置一个 <code>subdomain</code> 参数。</p>

<p>然后只需要将 <code>*.{subdomain_host}</code> 解析到 <code>FRP</code> 服务端所在服务器。之后用户可以通过 <code>subdomain</code> 自行指定自己的 <code>Web</code> 服务所需要使用的二级域名，并通过 <code>{subdomain}.{subdomain_host}</code> 来访问自己的 <code>Web</code> 服务。</p>

<p>首先我们在 <code>FRP</code> 服务端配置 <code>subdomain_host</code> 参数：</p>

<pre><code class="language-sh">$ vim frps.ini
[common]
subdomain_host = hi-linux.com
</code></pre>

<p>其次在 <code>FRP</code> 客户端配置文件配置 <code>subdomain</code> 参数：</p>

<pre><code class="language-sh">$ vim frpc.ini
[web]
type = http
local_port = 80
subdomain = test
</code></pre>

<p>然后将泛域名 *.hi-linux.com 解析到 <code>FRP</code> 服务端所在服务器的公网 <code>IP</code> 地址。FRP 服务端 和 FRP 客户端都启动成功后，通过 <code>test.hi-linux.com</code> 就可以访问到内网的 <code>Web</code> 服务。</p>

<blockquote>
<ul>
<li>  同一个 <code>HTTP</code> 或 <code>HTTPS</code> 类型的代理中 <code>custom_domains</code> 和 <code>subdomain</code> 可以同时配置。</li>
<li>  需要注意的是如果 <code>FPR</code> 服务端配置了 <code>subdomain_host</code>，则 <code>custom_domains</code> 中不能是属于 <code>subdomain_host</code> 的子域名或者泛域名。</li>
</ul>
</blockquote>

<h5 id="toc_9"><a href="#%E4%BF%AE%E6%94%B9-host-header"></a>修改 Host Header</h5>

<p>通常情况下 <code>FRP</code> 不会修改转发的任何数据。但有一些后端服务会根据 <code>HTTP</code> 请求 <code>header</code> 中的 host 字段来展现不同的网站，例如 <code>Nginx</code> 的虚拟主机服务，启用 host-header 的修改功能可以动态修改 <code>HTTP</code> 请求中的 host 字段。</p>

<p>实现此功能只需要在 FRP 客户端配置文件中定义 <code>host_header_rewrite</code> 参数。</p>

<pre><code class="language-sh">$ vim frpc.ini
[web]
type = http
local_port = 80
custom_domains = test.hi-linux.com
host_header_rewrite = dev.hi-linux.com
</code></pre>

<p>原来 <code>HTTP</code> 请求中的 host 字段 <code>test.hi-linux.com</code> 转发到后端服务时会被替换为 <code>dev.hi-linux.com</code>。</p>

<blockquote>
<ul>
<li>  该功能仅限于 HTTP 类型的代理。</li>
</ul>
</blockquote>

<h5 id="toc_10"><a href="#url-%E8%B7%AF%E7%94%B1"></a>URL 路由</h5>

<p><code>FRP</code> 支持根据请求的 <code>URL</code> 路径路由转发到不同的后端服务。要实现这个功能可通过 <code>FRP</code> 客户端配置文件中的 <code>locations</code> 字段来指定。</p>

<pre><code class="language-sh">$ vim frpc.ini

[web01]
type = http
local_port = 80
custom_domains = web.hi-linux.com
locations = /

[web02]
type = http
local_port = 81
custom_domains = web.hi-linux.com
locations = /news,/about
</code></pre>

<p>按照上述的示例配置后，<code>web.hi-linux.com</code> 这个域名下所有以 /news 以及 /about 作为前缀的 <code>URL</code> 请求都会被转发到后端 web02 所在的后端服务，其余的请求会被转发到 web01 所在的后端服务。</p>

<blockquote>
<ul>
<li>  目前仅支持最大前缀匹配，之后会考虑支持正则匹配。</li>
</ul>
</blockquote>

<h4 id="toc_11"><a href="#%E9%80%9A%E8%BF%87-udp-%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91%E6%9C%BA%E5%99%A8"></a>通过 UDP 访问内网机器</h4>

<p><code>DNS</code> 查询请求通常使用 <code>UDP</code> 协议，<code>FRP</code> 支持对内网 <code>UDP</code> 服务的穿透，配置方式和 <code>TCP</code> 基本一致。这里以转发到 Google 的 <code>DNS</code> 查询服务器 8.8.8.8 的 <code>UDP</code> 端口为例。</p>

<p>首先修改 FRP 客户端配置文件，并增加如下内容：</p>

<pre><code class="language-sh">$ vim frpc.ini
[dns]
type = udp
local_ip = 8.8.8.8
local_port = 53
remote_port = 6001
</code></pre>

<blockquote>
<ul>
<li>  要转发到内网 DNS 服务器只需把 <code>local_ip</code> 改成对应 IP 即可。</li>
</ul>
</blockquote>

<p>其次重新启动 <code>FRP</code> 客户端：</p>

<pre><code class="language-sh">$ ./frpc -c ./frpc.ini
2018/01/25 14:54:17 [I] [proxy_manager.go:284] proxy removed: []
2018/01/25 14:54:17 [I] [proxy_manager.go:294] proxy added: [ssh web dns]
2018/01/25 14:54:17 [I] [proxy_manager.go:317] visitor removed: []
2018/01/25 14:54:17 [I] [proxy_manager.go:326] visitor added: []
2018/01/25 14:54:17 [I] [control.go:240] [33e1de8a771112a6] login to server success, get run id [33e1de8a771112a6], server udp port [0]
2018/01/25 14:54:17 [I] [control.go:165] [33e1de8a771112a6] [ssh] start proxy success
2018/01/25 14:54:17 [I] [control.go:165] [33e1de8a771112a6] [web] start proxy success
2018/01/25 14:54:17 [I] [control.go:165] [33e1de8a771112a6] [dns] start proxy success
</code></pre>

<p>最后通过 <code>dig</code> 命令测试 <code>UDP</code> 包转发是否成功，预期会返回 <code>www.google.com</code> 域名的解析结果：</p>

<pre><code class="language-sh">$ dig @4.3.2.1 -p 6001 www.google.com
...

;; QUESTION SECTION:
;www.google.com.            IN  A

;; ANSWER SECTION:
www.google.com.     79  IN  A   69.63.184.30

...
</code></pre>

<h4 id="toc_12"><a href="#%E8%BD%AC%E5%8F%91-unix-%E5%9F%9F%E5%A5%97%E6%8E%A5%E5%AD%97"></a>转发 Unix 域套接字</h4>

<p>通过 <code>TCP</code> 端口访问内网的 <code>Unix</code> 域套接字，这里以和本地机器上的 Docker Daemon 通信为例。</p>

<p>首先修改 <code>FRP</code> 客户端配置文件，并增加如下内容：</p>

<pre><code class="language-sh">$ vim frpc.ini
[unix_domain_socket]
type = tcp
remote_port = 6002
plugin = unix_domain_socket
plugin_unix_path = /var/run/docker.sock
</code></pre>

<p>这里主要是使用 <code>plugin</code> 和 <code>plugin_unix_path</code> 两个参数启用了 <code>unix_domain_socket</code> 插件和配置对应的套接字路径。</p>

<p>其次重新启动 <code>FRP</code> 客户端：</p>

<pre><code class="language-sh">$ ./frpc -c ./frpc.ini

2018/01/25 15:09:33 [I] [proxy_manager.go:284] proxy removed: []
2018/01/25 15:09:33 [I] [proxy_manager.go:294] proxy added: [ssh web dns unix_domain_socket]
2018/01/25 15:09:33 [I] [proxy_manager.go:317] visitor removed: []
2018/01/25 15:09:33 [I] [proxy_manager.go:326] visitor added: []
2018/01/25 15:09:33 [I] [control.go:240] [f6424f0deb8b6ff7] login to server success, get run id [f6424f0deb8b6ff7], server udp port [0]
2018/01/25 15:09:33 [I] [control.go:165] [f6424f0deb8b6ff7] [ssh] start proxy success
2018/01/25 15:09:33 [I] [control.go:165] [f6424f0deb8b6ff7] [web] start proxy success
2018/01/25 15:09:33 [I] [control.go:165] [f6424f0deb8b6ff7] [dns] start proxy success
2018/01/25 15:09:33 [I] [control.go:165] [f6424f0deb8b6ff7] [unix_domain_socket] start proxy success
</code></pre>

<p>最后通过 <code>curl</code> 命令查看 <code>Docker</code> 版本信息进行测试：</p>

<pre><code class="language-sh">$ curl http://4.3.2.1:6002/version

{&quot;Platform&quot;:{&quot;Name&quot;:&quot;&quot;},&quot;Components&quot;:[{&quot;Name&quot;:&quot;Engine&quot;,&quot;Version&quot;:&quot;17.12.0-ce&quot;,&quot;Details&quot;:{&quot;ApiVersion&quot;:&quot;1.35&quot;,&quot;Arch&quot;:&quot;amd64&quot;,&quot;BuildTime&quot;:&quot;2017-12-27T20:12:29.000000000+00:00&quot;,&quot;Experimental&quot;:&quot;true&quot;,&quot;GitCommit&quot;:&quot;c97c6d6&quot;,&quot;GoVersion&quot;:&quot;go1.9.2&quot;,&quot;KernelVersion&quot;:&quot;4.9.60-linuxkit-aufs&quot;,&quot;MinAPIVersion&quot;:&quot;1.12&quot;,&quot;Os&quot;:&quot;linux&quot;}}],&quot;Version&quot;:&quot;17.12.0-ce&quot;,&quot;ApiVersion&quot;:&quot;1.35&quot;,&quot;MinAPIVersion&quot;:&quot;1.12&quot;,&quot;GitCommit&quot;:&quot;c97c6d6&quot;,&quot;GoVersion&quot;:&quot;go1.9.2&quot;,&quot;Os&quot;:&quot;linux&quot;,&quot;Arch&quot;:&quot;amd64&quot;,&quot;KernelVersion&quot;:&quot;4.9.60-linuxkit-aufs&quot;,&quot;Experimental&quot;:true,&quot;BuildTime&quot;:&quot;2017-12-27T20:12:29.000000000+00:00&quot;}
</code></pre>

<blockquote>
<ul>
<li>  <code>FRP</code> 从 1.5 版本开始支持客户端热加载配置文件，并不用每次都重启客户端程序。具体方法在后文 <code>FRP</code> 客户端热加载配置文件部分讲解。</li>
</ul>
</blockquote>

<h3 id="toc_13"><a href="#frp-%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6"></a>FRP 高级进阶</h3>

<h4 id="toc_14"><a href="#%E7%BB%99-frp-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%B8%AA-dashboard"></a>给 FRP 服务端增加一个 Dashboard</h4>

<p>通过 <code>Dashboard</code> 可以方便的查看 <code>FRP</code> 的状态以及代理统计信息展示，要使用这个功能首先需要在 <code>FRP</code> 服务端配置文件中指定 <code>Dashboard</code> 服务使用的端口：</p>

<pre><code class="language-sh">$ vim frps.ini

[common]

# 指定 Dashboard 的监听的 IP 地址
dashboard_addr = 0.0.0.0

# 指定 Dashboard 的监听的端口
dashboard_port = 7500

# 指定访问 Dashboard 的用户名
dashboard_user = admin

# 指定访问 Dashboard 的端口
dashboard_pwd = admin
</code></pre>

<p>其次重新启动 FRP 服务端：</p>

<pre><code class="language-sh">$ ./frps -c ./frps.ini

2018/01/25 16:39:29 [I] [service.go:96] frps tcp listen on 0.0.0.0:7000
2018/01/25 16:39:29 [I] [service.go:125] http service listen on 0.0.0.0:8080
2018/01/25 16:39:29 [I] [service.go:164] Dashboard listen on 0.0.0.0:7500
2018/01/25 16:39:29 [I] [main.go:112] Start frps success
2018/01/25 16:39:29 [I] [main.go:114] PrivilegeMode is enabled, you should pay more attention to security issues
</code></pre>

<p>最后通过 <code>http://[server_addr]:7500</code> 访问 Dashboard 界面，用户名密码默认都为 admin。</p>

<p><img src="https://www.hi-linux.com/img/linux/frp1.png" alt=""/></p>

<p><img src="https://www.hi-linux.com/img/linux/frp2.png" alt=""/></p>

<h4 id="toc_15"><a href="#%E7%BB%99-frp-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8A%A0%E4%B8%8A%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81"></a>给 FRP 服务端加上身份验证</h4>

<p>默认情况下只要知道 <code>FRP</code> 服务端开放的端口，任意 <code>FRP</code> 客户端都可以随意在服务端上注册端口映射，这样对于在公网上的 <code>FRP</code> 服务来说显然不太安全。<code>FRP</code> 提供了身份验证机制来提高 <code>FRP</code> 服务端的安全性。要启用这一特性也很简单，只需在 <code>FRP</code> 服务端和 <code>FRP</code> 客户端的 common 配置中启用 <code>privilege_token</code> 参数就行。</p>

<pre><code class="language-sh">[common]
privilege_token = 12345678
</code></pre>

<p>启用这一特性后，只有 <code>FRP</code> 服务端和 <code>FRP</code> 客户端的 common 配置中的 <code>privilege_token</code> 参数一致身份验证才会通过，<code>FRP</code> 客户端才能成功在 <code>FRP</code> 服务端注册端口映射。否则就会注册失败，出现类似下面的错误：</p>

<pre><code class="language-sh">2018/01/25 17:29:27 [I] [proxy_manager.go:284] proxy removed: []
2018/01/25 17:29:27 [I] [proxy_manager.go:294] proxy added: [ssh web dns unix_domain_socket]
2018/01/25 17:29:27 [I] [proxy_manager.go:317] visitor removed: []
2018/01/25 17:29:27 [I] [proxy_manager.go:326] visitor added: []
2018/01/25 17:29:27 [E] [control.go:230] authorization failed
2018/01/25 17:29:27 [W] [control.go:109] login to server failed: authorization failed
authorization failed
</code></pre>

<blockquote>
<p>需要注意的是 <code>FRP</code> 客户端所在机器和 <code>FRP</code> 服务端所在机器的时间相差不能超过 15 分钟，因为时间戳会被用于加密验证中，防止报文被劫持后被其他人利用。这个超时时间可以在配置文件中通过 <code>authentication_timeout</code> 这个参数来修改，单位为秒，默认值为 900，即 15 分钟。如果修改为 0，则 <code>FRP</code> 服务端将不对身份验证报文的时间戳进行超时校验。</p>
</blockquote>

<h4 id="toc_16"><a href="#frp-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%83%AD%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"></a>FRP 客户端热加载配置文件</h4>

<p>当修改了 <code>FRP</code> 客户端中的配置文件，从 0.15 版本开始可以通过 <code>frpc reload</code> 命令来动态加载配置文件，通常会在 10 秒内完成代理的更新。</p>

<p>启用此功能需要在 <code>FRP</code> 客户端配置文件中启用 admin 端口，用于提供 <code>API</code> 服务。配置如下：</p>

<pre><code class="language-sh">$ vim frpc.ini

[common]
admin_addr = 127.0.0.1
admin_port = 7400
</code></pre>

<p>重启 <code>FRP</code> 客户端，以后就可通过热加载方式进行 <code>FRP</code> 客户端配置变更了。</p>

<pre><code class="language-sh">$ ./frpc -c ./frpc.ini
2018/01/25 18:04:25 [I] [proxy_manager.go:326] visitor added: []
2018/01/25 18:04:25 [I] [control.go:240] [3653b9a878f8acc7] login to server success, get run id [3653b9a878f8acc7], server udp port [0]
2018/01/25 18:04:25 [I] [service.go:49] admin server listen on 127.0.0.1:7400
2018/01/25 18:04:25 [I] [control.go:165] [3653b9a878f8acc7] [ssh] start proxy success
2018/01/25 18:04:25 [I] [control.go:165] [3653b9a878f8acc7] [web] start proxy success
2018/01/25 18:04:25 [I] [control.go:165] [3653b9a878f8acc7] [dns] start proxy success
2018/01/25 18:04:25 [I] [control.go:165] [3653b9a878f8acc7] [unix_domain_socket] start proxy success

$ ./frpc reload -c ./frpc.ini
reload success
</code></pre>

<p>等待一段时间后客户端会根据新的配置文件创建、更新、删除代理。</p>

<blockquote>
<ul>
<li>  需要注意的是 [common] 中的参数除了 start 外目前无法被修改。</li>
</ul>
</blockquote>

<p>启用 <code>admin_addr</code> 后，还可以通过 <code>frpc status -c ./frpc.ini</code> 命令在 FRP 客户端很方便的查看当前代理状态信息。</p>

<pre><code class="language-sh">$ ./frpc status -c ./frpc.ini

Proxy Status...
TCP
Name                Status   LocalAddr     Plugin              RemoteAddr           Error
ssh                 running  127.0.0.1:22                      4.3.2.1:6000
unix_domain_socket  running                unix_domain_socket  4.3.2.1:6002

UDP
Name  Status   LocalAddr   Plugin  RemoteAddr           Error
dns   running  8.8.8.8:53          4.3.2.1:6001

HTTP
Name  Status   LocalAddr     Plugin  RemoteAddr              Error
web   running  127.0.0.1:80          mike.hi-linux.com:8080
</code></pre>

<h4 id="toc_17"><a href="#%E7%BB%99-frp-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A2%9E%E5%8A%A0%E7%AB%AF%E5%8F%A3%E7%99%BD%E5%90%8D%E5%8D%95"></a>给 FRP 服务端增加端口白名单</h4>

<p>为了防止 <code>FRP</code> 端口被滥用，<code>FRP</code> 提供了指定允许哪些端口被分配的功能。可通过 <code>FRP</code> 服务端的配置文件中 <code>privilege_allow_ports</code> 参数来指定：</p>

<pre><code class="language-sh">$ vim frps.ini

[common]
privilege_allow_ports = 2000-3000,3001,3003,4000-5000
</code></pre>

<blockquote>
<p><code>privilege_allow_ports</code> 可以配置允许使用的某个指定端口或者是一个范围内的所有端口，以 , 分隔，指定的范围以 - 分隔。</p>
</blockquote>

<p>当使用不允许的端口注册时，就会注册失败。出现类似以下错误：</p>

<pre><code class="language-sh">$ ./frpc status -c ./frpc.ini
Proxy Status...
TCP
Name                Status       LocalAddr     Plugin              RemoteAddr            Error
ssh                 start error  127.0.0.1:22                      4.3.2.1:60000  port not allowed
unix_domain_socket  start error                unix_domain_socket  4.3.2.1:60002  port not allowed
</code></pre>

<h4 id="toc_18"><a href="#%E5%90%AF%E7%94%A8-tcp-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"></a>启用 TCP 多路复用</h4>

<p>从 v0.10.0 版本开始，客户端和服务器端之间的连接支持多路复用，不再需要为每一个用户请求创建一个连接，使连接建立的延迟降低，并且避免了大量文件描述符的占用，使 <code>FRP</code> 可以承载更高的并发数。</p>

<p>该功能默认启用，如需关闭可以在 <code>FRP</code> 服务端配置文件和 <code>FRP</code> 客户端配置文件中配置，该配置项在服务端和客户端必须一致：</p>

<pre><code class="language-sh"># frps.ini 和 frpc.ini 中
[common]
tcp_mux = false
</code></pre>

<h4 id="toc_19"><a href="#frp-%E5%BA%95%E5%B1%82%E9%80%9A%E4%BF%A1%E5%90%AF%E7%94%A8-kcp-%E5%8D%8F%E8%AE%AE"></a>FRP 底层通信启用 KCP 协议</h4>

<p>FRP 从 v0.12.0 版本开始，底层通信协议支持选择 <code>KCP</code> 协议，在弱网络环境下传输效率会提升明显，但是会有一些额外的流量消耗。</p>

<p>要开启 <code>KCP</code> 协议支持，首先要在 <code>FRP</code> 服务端配置文件中启用 <code>KCP</code> 协议支持：</p>

<pre><code class="language-sh">$ vim frps.ini
[common]
bind_port = 7000
# 指定一个 UDP 端口用于接收客户端请求 KCP 绑定的是 UDP 端口，可以和 bind_port 一样
kcp_bind_port = 7000
</code></pre>

<p>其次是在 <code>FRP</code> 客户端配置文件指定需要使用的协议类型，目前只支持 <code>TCP</code> 和 <code>KCP</code>。其它代理配置不需要变更：</p>

<pre><code class="language-sh">$ vim  frpc.ini
[common]
server_addr = 4.3.2.1
# server_port 指定为 FRP 服务端里 kcp_bind_port 指定的端口
server_port = 7000
# 指定需要使用的协议类型，默认类型为 TCP
protocol = kcp
</code></pre>

<blockquote>
<ul>
<li>  需要注意开放相关机器上的 UDP 端口的访问权限。</li>
</ul>
</blockquote>

<h4 id="toc_20"><a href="#%E7%BB%99-frp-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%85%8D%E7%BD%AE%E8%BF%9E%E6%8E%A5%E6%B1%A0"></a>给 FRP 服务端配置连接池</h4>

<p>默认情况下，当用户请求建立连接后，<code>FRP</code> 服务端才会请求 <code>FRP</code> 客户端主动与后端服务建立一个连接。</p>

<p>当为指定的 <code>FRP</code> 服务端启用连接池功能后，<code>FRP</code> 会预先和后端服务建立起指定数量的连接，每次接收到用户请求后，会从连接池中取出一个连接和用户连接关联起来，避免了等待与后端服务建立连接以及 <code>FRP</code> 客户端 和 <code>FRP</code> 服务端之间传递控制信息的时间。</p>

<p>首先需要在 <code>FRP</code> 服务端配置文件中设置每个代理可以创建的连接池上限，避免大量资源占用，客户端设置超过此配置后会被调整到当前值：</p>

<pre><code class="language-sh">$ vim frps.ini
[common]
max_pool_count = 5
</code></pre>

<p>其次在 <code>FRP</code> 客户端配置文件中为客户端启用连接池，指定预创建连接的数量：</p>

<pre><code class="language-sh">$ vim frpc.ini
[common]
pool_count = 1
</code></pre>

<blockquote>
<ul>
<li>  此功能比较适合有大量短连接请求时开启。</li>
</ul>
</blockquote>

<h4 id="toc_21"><a href="#%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%8E%8B%E7%BC%A9"></a>加密与压缩</h4>

<p>如果公司内网防火墙对外网访问进行了流量识别与屏蔽，例如禁止了 <code>SSH</code> 协议等，可通过设置 use_encryption = true，将 <code>FRP</code> 客户端 与 <code>FRP</code> 服务端之间的通信内容加密传输，将会有效防止流量被拦截。</p>

<p>如果传输的报文长度较长，通过设置 use_compression = true 对传输内容进行压缩，可以有效减小 <code>FRP</code> 客户端 与 <code>FRP</code> 服务端之间的网络流量，来加快流量转发速度，但是会额外消耗一些 CPU 资源。</p>

<p>这两个功能默认是不开启的，需要在 <code>FRP</code> 客户端配置文件中通过配置来为指定的代理启用加密与压缩的功能，压缩算法使用的是 snappy。</p>

<pre><code class="language-sh">$ vim frpc.ini

[ssh]
type = tcp
local_port = 22
remote_port = 6000
use_encryption = true
use_compression = true
</code></pre>

<h4 id="toc_22"><a href="#%E9%80%9A%E8%BF%87-frp-%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%90%86%E5%85%B6%E5%AE%83%E5%86%85%E7%BD%91%E6%9C%BA%E5%99%A8%E8%AE%BF%E9%97%AE%E5%A4%96%E7%BD%91"></a>通过 FRP 客户端代理其它内网机器访问外网</h4>

<p><code>FRP</code> 客户端内置了 <code>http_proxy</code> 和 <code>socks5</code> 插件，通过这两个插件可以使其它内网机器通过 <code>FPR</code> 客户端的的网络访问互联网。</p>

<p>要启用此功能，首先需要在 <code>FRP</code> 客户端配置文件中启用相关插件，这里以 <code>http_proxy</code> 插件为例：</p>

<pre><code class="language-sh">$ vim frpc.ini

[common]
server_addr = 4.3.2.1
server_port = 7000

[http_proxy]
type = tcp
remote_port = 6000
plugin = http_proxy
</code></pre>

<p>其次将需要通过这个代理访问外网的内部机器的代理地址设置为 4.3.2.1:6000，这样就可以通过 FRP 客户端机器的网络访问互联网了。</p>

<blockquote>
<ul>
<li>  <code>http_proxy</code> 插件也支持认证机制，如果需要启用认证可通过配置参数 <code>plugin_http_user</code> 和 <code>plugin_http_passwd</code> 启用。</li>
<li>  如需启用 <code>Socks5</code> 代理，只需将 plugin 的值更换为 socks5 即可。</li>
</ul>
</blockquote>

<h4 id="toc_23"><a href="#%E9%80%9A%E8%BF%87%E4%BB%A3%E7%90%86%E8%BF%9E%E6%8E%A5-frp-%E6%9C%8D%E5%8A%A1%E7%AB%AF"></a>通过代理连接 FRP 服务端</h4>

<p>在只能通过代理访问外网的环境内，<code>FRP</code> 客户端支持通过 <code>HTTP_PROXY</code> 参数来配置代理和 <code>FRP</code> 服务端进行通信。要使用此功能可以通过设置系统环境变量 <code>HTTP_PROXY</code> 或者通过在 <code>FRP</code> 客户端的配置文件中设置 <code>http_proxy</code> 参数来使用此功能。</p>

<pre><code class="language-sh">$ vim frpc.ini

[common]
server_addr = 4.3.2.1
server_port = 7000
protocol = tcp
http_proxy = http://user:pwd@4.3.2.2:8080
</code></pre>

<blockquote>
<ul>
<li>  仅在 <code>protocol = tcp</code> 时生效，暂时不支持 kcp 协议。</li>
</ul>
</blockquote>

<h4 id="toc_24"><a href="#%E5%AE%89%E5%85%A8%E5%9C%B0%E6%9A%B4%E9%9C%B2%E5%86%85%E7%BD%91%E6%9C%8D%E5%8A%A1"></a>安全地暴露内网服务</h4>

<p>对于一些比较敏感的服务如果直接暴露于公网上将会存在安全隐患，<code>FRP</code> 也提供了一种安全的转发方式 <code>STCP</code>。使用 <code>STCP</code> (secret tcp) 类型的代理可以避免让任何人都能访问到穿透到公网的内网服务，要使用 <code>STCP</code> 模式访问者需要单独运行另外一个 <code>FRP</code> 客户端。</p>

<p>下面就以创建一个只有自己能访问到的 <code>SSH</code> 服务代理为例，<code>FRP</code> 服务端和其它的部署步骤相同，主要区别是在 <code>FRP</code> 客户端上。</p>

<p>首先配置 <code>FRP</code> 客户端，和常规 <code>TCP</code> 转发不同的是这里不需要指定远程端口。</p>

<pre><code class="language-sh">$ vim frpc.ini
[common]
server_addr = 4.3.2.1
server_port = 7000

[secret_ssh]
type = stcp
# 只有 sk 一致的用户才能访问到此服务
sk = abcdefg
local_ip = 127.0.0.1
local_port = 22
</code></pre>

<p>其次在要访问这个服务的机器上启动另外一个 <code>FRP</code> 客户端，配置如下：</p>

<pre><code class="language-sh">$ vim frpc.ini
[common]
server_addr = 4.3.2.1
server_port = 7000

[secret_ssh_visitor]
type = stcp
# STCP 的访问者
role = visitor
# 要访问的 STCP 代理的名字，和前面定义的相同。
server_name = secret_ssh
# 和前面定义的要一致
sk = abcdefg
# 绑定本地端口用于访问 ssh 服务
bind_addr = 127.0.0.1
bind_port = 6005
</code></pre>

<p>最后在本机启动一个 <code>FRP</code> 客户端，这样就可以通过本机 6005 端口对内网机器 <code>SSH</code> 服务进行访问，假设用户名为 mike：</p>

<pre><code class="language-sh">$ ./frpc -c ./frpc.ini
2018/01/26 15:03:24 [I] [proxy_manager.go:284] proxy removed: []
2018/01/26 15:03:24 [I] [proxy_manager.go:294] proxy added: []
2018/01/26 15:03:24 [I] [proxy_manager.go:317] visitor removed: []
2018/01/26 15:03:24 [I] [proxy_manager.go:326] visitor added: [secret_ssh_visitor]
2018/01/26 15:03:24 [I] [control.go:240] [60d2af2f68196537] login to server success, get run id [60d2af2f68196537], server udp port [0]
2018/01/26 15:03:24 [I] [proxy_manager.go:235] [60d2af2f68196537] try to start visitor [secret_ssh_visitor]
2018/01/26 15:03:24 [I] [proxy_manager.go:243] [secret_ssh_visitor] start visitor success

$ ssh -oPort=6005 mike@127.0.0.1
</code></pre>

<h4 id="toc_25"><a href="#%E7%82%B9%E5%AF%B9%E7%82%B9%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F"></a>点对点内网穿透</h4>

<p>在传输大量数据时如果都经过服务器中转的话，这样会对服务器端带宽压力比较大。<code>FRP</code> 提供了一种新的代理类型 <code>XTCP</code> 来解决这个问题，<code>XTCP</code> 模式下可以在传输大量数据时让流量不经过服务器中转。</p>

<p>使用方式同 <code>STCP</code> 类似，需要在传输数据的两端都部署上 <code>FRP</code> 客户端上用于建立直接的连接。</p>

<p>首先在 <code>FRP</code> 服务端配置上增加一个 <code>UDP</code> 端口用于支持该类型的客户端:</p>

<pre><code class="language-sh">$ vim frps.ini
bind_udp_port = 7001
</code></pre>

<p>其次配置 <code>FRP</code> 客户端，和常规 <code>TCP</code> 转发不同的是这里不需要指定远程端口。</p>

<pre><code class="language-sh">$ vim frpc.ini

[common]
server_addr = 4.3.2.1
server_port = 7000

[p2p_ssh]
type = xtcp
# 只有 sk 一致的用户才能访问到此服务
sk = abcdefg
local_ip = 127.0.0.1
local_port = 22
</code></pre>

<p>然后在要访问这个服务的机器上启动另外一个 <code>FRP</code> 客户端，配置如下：</p>

<pre><code class="language-sh">$ vim frpc.ini
[common]
server_addr = 4.3.2.1
server_port = 7000

[p2p_ssh_visitor]
type = xtcp
# XTCP 的访问者
role = visitor
# 要访问的 XTCP 代理的名字
server_name = p2p_ssh
sk = abcdefg
# 绑定本地端口用于访问 ssh 服务
bind_addr = 127.0.0.1
bind_port = 6006
</code></pre>

<p>最后在本机启动一个 FRP 客户端，这样就可以通过本机 6006 端口对内网机器 SSH 服务进行访问，假设用户名为 mike：</p>

<pre><code class="language-sh">$ ./frpc -c ./frpc.ini

2018/01/26 16:01:52 [I] [proxy_manager.go:326] visitor added: [p2p_ssh_visitor secret_ssh_visitor]
2018/01/26 16:01:52 [I] [control.go:240] [7c7e06878e11cc3c] login to server success, get run id [7c7e06878e11cc3c], server udp port [7001]
2018/01/26 16:01:52 [I] [proxy_manager.go:235] [7c7e06878e11cc3c] try to start visitor [p2p_ssh_visitor]
2018/01/26 16:01:52 [I] [proxy_manager.go:243] [p2p_ssh_visitor] start visitor success
2018/01/26 16:01:52 [I] [proxy_manager.go:235] [7c7e06878e11cc3c] try to start visitor [secret_ssh_visitor]
2018/01/26 16:01:52 [I] [proxy_manager.go:243] [secret_ssh_visitor] start visitor success

$ ssh -oPort=6006 mike@127.0.0.1
</code></pre>

<blockquote>
<ul>
<li>  目前 <code>XTCP</code> 模式还处于开发的初级阶段，并不能穿透所有类型的 <code>NAT</code> 设备，所以穿透成功率较低。穿透失败时可以尝试 <code>STCP</code> 的方式。</li>
</ul>
</blockquote>

<h3 id="toc_26"><a href="#frp-%E7%AE%A1%E7%90%86"></a>FRP 管理</h3>

<p><code>FRP</code> 的部署安装比较简单，项目官方也没有提供相应的管理脚本。不过好在开源项目总是有网友热心提供部署和管理脚本。如果你觉得手动部署太麻烦，还可以使用下面的一键安装脚本。</p>

<p>项目地址：<a href="https://github.com/clangcn/onekey-install-shell/">https://github.com/clangcn/onekey-install-shell/</a></p>

<h4 id="toc_27"><a href="#%E4%B8%8B%E8%BD%BD%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2%E8%84%9A%E6%9C%AC"></a>下载一键部署脚本</h4>

<pre><code class="language-sh">$ wget --no-check-certificate https://raw.githubusercontent.com/clangcn/onekey-install-shell/master/frps/install-frps.sh -O ./install-frps.sh
$ chmod 700 ./install-frps.sh
</code></pre>

<h4 id="toc_28"><a href="#%E5%AE%89%E8%A3%85-frp-%E6%9C%8D%E5%8A%A1%E7%AB%AF"></a>安装 FRP 服务端</h4>

<p>这个一键部署脚本比较好用，为了提高国内用户下载安装包速度还提供了阿里云节点的安装源。整个脚本使用起来也比较简单，对一些常用的 <code>FRP</code> 服务端配置参数都做了交互式选择让用户可以方便的根据自己实际情况进行选择。脚本比较贴心的一点是对默认的公网地址进行了检测，省去了手动输入的麻烦。</p>

<pre><code class="language-sh">$ ./install-frps.sh install

Please select frps download url:
[1].aliyun (default)
[2].github
Enter your choice (1, 2 or exit. default [aliyun]):
---------------------------------------
Your select: aliyun
---------------------------------------
Loading network version for frps, please wait...
frps Latest release file frp_0.15.1_linux_amd64.tar.gz
Loading You Server IP, please wait...
You Server IP:12.34.56.78
Please input your server setting:

Please input frps bind_port [1-65535](Default Server Port: 5443):7000
frps bind_port: 7000

Please input frps vhost_http_port [1-65535](Default vhost_http_port: 80):8080
frps vhost_http_port: 8080

Please input frps vhost_https_port [1-65535](Default vhost_https_port: 443):
frps vhost_https_port: 443

Please input frps dashboard_port [1-65535](Default dashboard_port: 6443):7500
frps dashboard_port: 7500

Please input dashboard_user (Default: admin):
frps dashboard_user: admin

Please input dashboard_pwd (Default: IY0p1bOg):admin
frps dashboard_pwd: admin

Please input privilege_token (Default: 9BqswPpd1R0TfGR5):mike
frps privilege_token: mike

Please input frps max_pool_count [1-200]
(Default max_pool_count: 50):
frps max_pool_count: 50

##### Please select log_level #####
1: info (default)
2: warn
3: error
4: debug
#####################################################
Enter your choice (1, 2, 3, 4 or exit. default [1]):
log_level: info

Please input frps log_max_days [1-30]
(Default log_max_days: 3 day):
frps log_max_days: 3

##### Please select log_file #####
1: enable (default)
2: disable
#####################################################
Enter your choice (1, 2 or exit. default [1]):
log_file: enable

##### Please select tcp_mux #####
1: enable (default)
2: disable
#####################################################
Enter your choice (1, 2 or exit. default [1]):
tcp_mux: true

##### Please select kcp support #####
1: enable (default)
2: disable
#####################################################
Enter your choice (1, 2 or exit. default [1]):
kcp support: true

============== Check your input ==============
You Server IP      : 12.34.56.78
Bind port          : 7000
kcp support        : true
vhost http port    : 8080
vhost https port   : 443
Dashboard port     : 7500
Dashboard user     : admin
Dashboard password : admin
Privilege token    : mike
tcp_mux            : true
Max Pool count     : 50
Log level          : info
Log max days       : 3
Log file           : enable
==============================================

Press any key to start...or Press Ctrl+c to cancel

frps install path:/usr/local/frps
config file for frps ... done
download frps ... done
download /etc/init.d/frps... done
setting frps boot... done

+--------------------------------------------------+
|        Manager for Frps, Written by Clang        |
+--------------------------------------------------+
| Intro: http://koolshare.cn/thread-65379-1-1.html |
+--------------------------------------------------+

Starting Frps(0.15.1)... done
Frps (pid 3325)is running.

+---------------------------------------------------------+
|        frps for Linux Server, Written by Clang          |
+---------------------------------------------------------+
|     A tool to auto-compile &amp; install frps on Linux      |
+---------------------------------------------------------+
|    Intro: http://koolshare.cn/thread-65379-1-1.html     |
+---------------------------------------------------------+

Congratulations, frps install completed!
==============================================
You Server IP      : 12.34.56.78
Bind port          : 7000
KCP support        : true
vhost http port    : 8080
vhost https port   : 443
Dashboard port     : 7500
Privilege token    : mike
tcp_mux            : true
Max Pool count     : 50
Log level          : info
Log max days       : 3
Log file           : enable
==============================================
frps Dashboard     : http://12.34.56.78:7500/
Dashboard user     : admin
Dashboard password : admin
==============================================
</code></pre>

<h4 id="toc_29"><a href="#%E9%85%8D%E7%BD%AE-frp-%E6%9C%8D%E5%8A%A1%E7%AB%AF"></a>配置 FRP 服务端</h4>

<pre><code class="language-sh">$ ./install-frps.sh config
</code></pre>

<h4 id="toc_30"><a href="#%E6%9B%B4%E6%96%B0-frp-%E6%9C%8D%E5%8A%A1%E7%AB%AF"></a>更新 FRP 服务端</h4>

<pre><code class="language-sh">$ ./install-frps.sh update
</code></pre>

<h4 id="toc_31"><a href="#%E5%8D%B8%E8%BD%BD-frp-%E6%9C%8D%E5%8A%A1%E7%AB%AF"></a>卸载 FRP 服务端</h4>

<pre><code class="language-sh">$ ./install-frps.sh uninstall
</code></pre>

<h4 id="toc_32"><a href="#frp-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%97%A5%E5%B8%B8%E7%AE%A1%E7%90%86"></a>FRP 服务端日常管理</h4>

<p><code>FRP</code> 服务端安装完成后，一键部署脚本还提供了一个日常管理 <code>FRP</code> 服务端的管理脚本来进行日常的启动、重启、停止等操作，非常的方便。</p>

<pre><code class="language-sh">Usage: /etc/init.d/frps {start|stop|restart|status|config|version}
</code></pre>

<h3 id="toc_33"><a href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3"></a>参考文档</h3>

<p><a href="http://www.google.com">http://www.google.com</a><br/>
<a href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a><br/>
<a href="http://koolshare.cn/thread-65379-1-1.html">http://koolshare.cn/thread-65379-1-1.html</a></p>


    

      </div>

      <div class="row">
        <div class="large-6 columns">
        <p class="text-left" style="padding:15px 0px;">
      
          <a href="15516093053616.html" 
          title="Previous Post: Monitoring and Managing Workflows Across Collaborating Microservices">&laquo; Monitoring and Managing Workflows Across Collaborating Microservices</a>
      
        </p>
        </div>
        <div class="large-6 columns">
      <p class="text-right" style="padding:15px 0px;">
      
          <a  href="15514073814858.html" 
          title="Next Post: 初识 MQTT">初识 MQTT &raquo;</a>
      
      </p>
        </div>
      </div>
      <div class="comments-wrap">
        <div class="share-comments">
          <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5ae58078c0d7b2ab"></script>

          

          
        </div>
      </div>
    </div><!-- article-wrap -->
  </div><!-- large 8 -->




 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="./asset/img/logo.jpg" /></div>
            
                <h1>Junkman</h1>
                <div class="site-des">“拾荒者”一词来自凯文・凯利的《失控》中关于机器学习的故事（“收集癖好机”如何完成他的收集工作）。</div>
                <div class="social">









<a target="_blank" class="github" target="_blank" href="https://github.com/panlw/" title="GitHub">GitHub</a>

  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Infra.html"><strong>Infra</strong></a>
        
            <a href="Coding.html"><strong>Coding</strong></a>
        
            <a href="Modeling.html"><strong>Modeling</strong></a>
        
            <a href="Archtecting.html"><strong>Archtecting</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15517999043443.html">The Art of Crafting Architectural Diagrams</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15517997955971.html">为什么说我们需要软件架构图？</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15516128677869.html">DNS Servers That Offer Privacy and Filtering</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15516123108194.html">Airbnb's Migration from Monolith to Services</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15516097487470.html">Events As First-Class Citizens</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    <script src="asset/chart/all-min.js"></script><script type="text/javascript">$(function(){    var mwebii=0;    var mwebChartEleId = 'mweb-chart-ele-';    $('pre>code').each(function(){        mwebii++;        var eleiid = mwebChartEleId+mwebii;        if($(this).hasClass('language-sequence')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = Diagram.parse($(this).text());            diagram.drawSVG(eleiid,{theme: 'simple'});        }else if($(this).hasClass('language-flow')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = flowchart.parse($(this).text());            diagram.drawSVG(eleiid);        }    });});</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
